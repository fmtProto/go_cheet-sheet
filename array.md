## `Array(Массив)`
> - [Объявление массива](#var-declaration)
> - [Обращение к элементам](#var-read)
> - [Запись / Перезапись элементов](#var-write)
> - [Удаление элементов](#var-delete)
> - [Длина массива](#len)
> - [Копирование массива](#copy)
> - [Добавление элементов](#add)
> - [Циклы](#cycles)
>    - for
>    - for range
> - [Конвертация](#сonversion)
>    - array -> slice

**`Array(Массив)`** - непрерывная последовательность элементов одного типа, обладающая фиксированной, неизменяемой длиной.
- элементы массива хранятся в памяти последовательно и непрерывно
- все элементы массива имеют одинаковый тип данных
- длина  массива неизменяема
- массив по  умолчанию передается по значению, то есть копируется
- длина массива - это часть его типа, поэтому массивы с разной длиной, хоть и с одинаковыми элементами не соответствуют по типу  и  соответсвенно не равны

## Объявление переменных <a name="var-declaration"></a>

```go
var arr [размер]тип_элементов{элемент1, элемент2, элементN}
```
Если массив или один из его элементов не был инициализирован в коде, ему присваивается значение по умолчанию(нулевые значения) своего типа.
```go
var arr1 [3]int      // [0 0 0]
arr2 := [3]int{}     // [0 0 0] 
arr3 := [5]int{1,2}  // [1 2 0 0 0]
```
В массиве можно инициализировать только определенные элементы. 
```go
arr1 := [3]int{1: 12, 2: 25} // [0 12 25] 
arr2 := [5]int{1:10, 2:40}    // [0 10 40 0 0]
```
```go
arr2 := [...]int{1, 2, 3}    // [1 2 3] компилятор определит длину массива на основе количества элементов
```
## Обращение к элементам <a name="var-read"></a>

Получить доступ к определенному элементу массива, можно обратившись к номеру индекса.
имеет  сложность `O(1)`:
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[1]) // 2
```
При попытке получить доступ к элементу за пределами диапазона массива компилятор Go сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[5]) // invalid argument: index 5 out of bounds [0:3]
```
## Запись / Перезапись элементов <a name="var-write"></a>

Изменить значение определенного элемента массива, можно также обратившись к номеру индекса.
имеет  сложность `O(1)`:
```go
arr := [3]int{1, 2, 3}
arr[1] = 45
fmt.Println(arr[1]) // 45
```
При попытке получить доступ к элементу за пределами диапазона массива компилятор Go сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
arr[5] = 45 // invalid argument: index 5 out of bounds [0:3]
```

## Удаление элементов <a name="var-delete"></a>
Невозможно! Длина массива неизменяема!  

## Длина массива <a name="len"></a>
`len()` - вернет количество элементов массива
```go
arr := [3]int{1, 2, 3}
fmt.Println(len(arr)) // 3
```

## Копирование массива <a name="copy"></a>
Через присвоение:
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1
// arr1 и arr2 равны друг другу, имеют РАЗНОЕ адрессное пространство и никак не связанны друг с другом
```

## Добавление элементов <a name="add"></a>
Невозможно! Длина массива неизменяема! 

## Циклы <a name="cycles"></a>
### For
```go
arr := [3]int{1, 2, 3}
for i := 0; i < len(arr); i++ {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
### For range
Для изменения текущего массива нужно обращаться через индексы:
```go
arr := [3]int{1, 2, 3}
for i := range arr {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
Без этого текущий массив не будет изменен:
```go 
arr := [3]int{1, 2, 3}
for _, v := range arr {
    v = v * 2
    fmt.Println(v) // на кажом шаге итерации, последовательно -> 2 4 6
}
fmt.Println(arr) // [1 2 3] массив не изменен
```

## Многомерные массивы 
```go
var two [2][3]int
    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            two[i][j] = i + j
        }
    }
fmt.Println(two) // [[0 1 2] [1 2 3]]
```

## Конвертация <a name="сonversion"></a>

### Array -> Slice
```go
arr :=  [3]int{1, 2, 3}
slice := arr[:] // slice [1 2 3] является ссылкой на arr
```
