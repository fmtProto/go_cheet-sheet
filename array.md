## `Array(Массив)`
> - [Объявление массива](#declaration)
> - [Элементы массива](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина массива](#len)
> - [Копирование массива](#copy)
> - [Циклы](#cycles)
>   - for
>    - for range
> - [Конвертация](#сonversion)
>    - array -> slice

**`Array(Массив)`** - непрерывная последовательность элементов одного типа, обладающая фиксированной, неизменяемой длиной.
- элементы массива хранятся в памяти последовательно и непрерывно
- все элементы массива имеют одинаковый тип данных
- длина  массива неизменяема
- массив по  умолчанию передается по значению, то есть копируется
- длина массива - это часть его типа, поэтому массивы с разной длиной, не соответствуют по типу

## Объявление массива <a name="declaration"></a>
Для объявления массива требуется:
- указать длину массива
- указать тип элементов
- указать сами элементы(необязательно)
```go
[длина]тип_элементов{элемент1, элемент2, элементN}
[3]int{1, 2, 3}
[2]string{"one", "two"}
[5]int{} // без указания элементов
```

Если элементы не указаны, то им присваиваются значения по умолчанию(нулевые значения) указанного типа.
```go
var arr1 [3]int              // [0 0 0]
arr2 := [3]float64{}         // [0 0 0] 

arr3 := [3]string{}
fmt.Printf("%q", arr3)       // ["" "" ""]
```

В массиве можно инициализировать элементы по определенным индексам.
```go
// явно указав индексы
arr1 := [3]int{1: 12, 2: 25}   // [0 12 25] 
arr2 := [5]int{1: 10, 2: 40}   // [0 10 40 0 0]

// без явного указания индексов
arr3 := [5]int{1, 2}         // [1 2 0 0 0]
arr4 := [5]int{0, 0, 1, 7}   // [0 0 1 7 0]
```

Вместо длины можно указать `...` , что заставит компилятор определить длину массива на основе количества элементов.
```go
arr2 := [...]int{1, 2, 3}    // [1 2 3] 
```
## Элементы массива <a name="elements"></a>

### Обращение к элементам <a name="read"></a>
Получить доступ к определенному элементу массива, можно обратившись к нему по номеру индекса.
Имеет  сложность `O(1)`.
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[1]) // 2
```
При попытке получить доступ к элементу за пределами диапазона массива, компилятор сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[5]) // invalid argument: index 5 out of bounds [0:3]
```

### Изменение элементов <a name="edit"></a>
Изменить значение определенного элемента массива, можно обратившись к нему по номеру индекса.
Имеет  сложность `O(1)`.
```go
arr := [3]int{1, 2, 3}
arr[1] = 45
fmt.Println(arr[1]) // 45
```

При попытке получить доступ к элементу за пределами диапазона массива, компилятор сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
arr[5] = 45 // invalid argument: index 5 out of bounds [0:3]
```

При попытке изменить элемент на значение другого типа, вызовет ошибку.
```go
arr := [3]int{1, 2, 3}
arr[0] = "one" // cannot use "one" (untyped string constant) as int value in assignment
```

### Добавление элементов <a name="add"></a>
Невозможно! Длина массива неизменяема! 

### Удаление элементов <a name="delete"></a>
Невозможно! Длина массива неизменяема!  

## Длина массива <a name="len"></a>
`len()` - вернет количество элементов массива
```go
arr := [3]int{1, 2, 3}
fmt.Println(len(arr)) // 3
```

## Копирование массива <a name="copy"></a>
Через присвоение:
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1
// arr1 и arr2 равны друг другу, имеют РАЗНОЕ адрессное пространство и никак не связанны друг с другом
```



## Циклы <a name="cycles"></a>
### For
```go
arr := [3]int{1, 2, 3}
for i := 0; i < len(arr); i++ {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
### For range
Для изменения текущего массива нужно обращаться через индексы:
```go
arr := [3]int{1, 2, 3}
for i := range arr {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
Без этого текущий массив не будет изменен:
```go 
arr := [3]int{1, 2, 3}
for _, v := range arr {
    v = v * 2
    fmt.Println(v) // на кажом шаге итерации, последовательно -> 2 4 6
}
fmt.Println(arr) // [1 2 3] массив не изменен
```

## Многомерные массивы 
```go
var two [2][3]int
    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            two[i][j] = i + j
        }
    }
fmt.Println(two) // [[0 1 2] [1 2 3]]
```

## Конвертация <a name="сonversion"></a>

### Array -> Slice
```go
arr :=  [3]int{1, 2, 3}
slice := arr[:] // slice [1 2 3] является ссылкой на arr
```
