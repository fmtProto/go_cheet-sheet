## `Array(Массив)`
> - [Объявление массива](#declaration)
> - [Элементы массива](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина массива](#len)
> - [Копирование массива](#copy)
> - [Сравнение массивов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные массивы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение массива
>   - Содержит ли один массив, значения другого массива

**`Array(Массив)`** - непрерывная последовательность элементов одного типа, которая обладает фиксированной, неизменяемой длиной, с доступом к элементам по индексам.  
В исходниках Go массив представлен как:
```go
type Array struct {
    len  int64
    elem Type
}
```
- элементы массива хранятся в памяти последовательно и непрерывно
- все элементы массива имеют одинаковый тип данных
- для доступа к элементам массива используются индексы, начинающиеся с `0` по `len(array) - 1`
- нельзя изменить размер массива(длину) после его объявления.
- массив по  умолчанию передается по значению, то есть копируется
- длина массива - это часть его типа, поэтому массивы с разной длиной, не соответствуют по типу

## Объявление массива <a name="declaration"></a>
Для объявления массива требуется:
- указать длину массива(или использовать `...`)
- указать тип элементов
- указать сами элементы(необязательно)

```go
// формат объявления массива 
var array_name = [length]dataType{value1, value2, valueN}
array_name := [length]dataType{value1, value2, valueN} 

// примеры
var arr1 = [3]int{1, 2, 3}      // [1 2 3]
arr2 := [2]string{"one", "two"} // [one two]
arr3 := [5]int{}                // [0 0 0 0 0] без указания элементов
arr4 := [...]int{1, 2, 3}       // [1 2 3]
arr5 := [...]int{}              // []
```

Если элементы не указаны, то им присваиваются значения по умолчанию(нулевые значения) указанного типа.
```go
var arr1 [3]int         // [0 0 0]
var arr2 = [3]float32{} // [0 0 0] 
arr3 := [3]bool{}       // [false false false]
arr4 := [5]string{}     // [    ]
fmt.Printf("%q", arr4)  // ["" "" "" "" ""]
```

В массиве можно инициализировать элементы по определенным индексам.
```go
// явно указав индексы
arr1 := [3]int{1: 12, 2: 25}   // [0 12 25] 
arr2 := [5]int{1: 10, 2: 40}   // [0 10 40 0 0]

// без явного указания индексов
arr3 := [5]int{1, 2}         // [1 2 0 0 0]
arr4 := [5]int{0, 0, 1, 7}   // [0 0 1 7 0]
```

Вместо длины массива можно указать `...` , что заставит компилятор определить длину массива на основе количества элементов.
```go
arr := [...]int{1, 2, 3} // [1 2 3]
fmt.Println(len(arr))    // 3
```

При объявлении массива можно использовать многострочный синтаксис. После последнего элемента обязательно должна присутствовать запятая.
```go
arr := [4]float64{
    23.45,
    678.2,
    12,
    56.0,
} // [23.45 678.2 12 56]
```
## Элементы массива <a name="elements"></a>

### Обращение к элементам <a name="read"></a>
Поскольку элементы массива хранятся в памяти непрерывно, то получить доступ к определенному элементу массива, можно обратившись к нему по номеру индекса.  
Имеет  сложность `O(1)`.
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[1]) // 2
```
При попытке получить доступ к элементу за пределами диапазона массива, компилятор сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[5]) // invalid argument: index 5 out of bounds [0:3]
```
Go не поддерживает обратную индексацию с использованием отрицательных чисел, будет выведена ошибка.
```go
arr := [2]string{"one", "two"}
fmt.Println(arr[-1]) // invalid argument: index -1 (constant of type int) must not be negative
```

### Изменение элементов <a name="edit"></a>
Изменить значение определенного элемента массива, можно обратившись к нему по номеру индекса.  
Имеет  сложность `O(1)`.
```go
arr := [3]int{1, 2, 3}
arr[1] = 45
fmt.Println(arr) // [1 45 3]
```

При попытке получить доступ к элементу за пределами диапазона массива, компилятор сообщит об ошибке.
```go
arr := [3]int{1, 2, 3}
arr[5] = 45 // invalid argument: index 5 out of bounds [0:3]
```

При попытке изменить элемент на значение другого типа, вызовет ошибку.
```go
arr := [3]int{1, 2, 3}
arr[0] = "one" // cannot use "one" (untyped string constant) as int value in assignment
```

### Добавление элементов <a name="add"></a>
Невозможно! Длина массива неизменяема! 

### Удаление элементов <a name="delete"></a>
Невозможно! Длина массива неизменяема!  

## Длина массива <a name="len"></a>
В Go размер массива(длина) является частью его типа. Это означает, что два массива с разным количеством элементов относятся к двум разным типам, и один не может быть присвоен другому, это вызовет ошибку. По этой же причине длина массива фиксируется при создании и не может быть изменена позже.
```go
arr1 := [3]int{1, 2, 3}
arr2 := [2]int{1, 2}
arr1 = arr2 // cannot use arr2 (variable of type [2]int) as type [3]int in assignment)
```

Для получения количества элементов массива(длины массива), можно использовать функцию `len()`, она вернет количество элементов в указанном массиве.
```go
arr := [3]int{1, 2, 3}
fmt.Println(len(arr)) // 3
```

Так же стоит отметить, что функцию `cap()` показывающую вместимость в слайсах, можно использовать и с массивами, это не вызовет ошибку, однако использовать ее не идиоматически. В массивах результат `cap()` всегда равен результату `len()`, понимая устройство массивов это не должно вызывать вопросов.
```go
arr := [3]int{1, 2, 3}
fmt.Println(cap(arr)) // 3
fmt.Println(len(arr)) // 3
```

## Копирование массива <a name="copy"></a>
Так как массив НЕ является ссылочным типом данных(как, к примеру `slice`), то скопировать его можно через присвоение. Это создаст полностью индентичный массив, но в новых ячейках памяти. Оба массива будут иметь абсолютно РАЗНОЕ адресное пространство и изменение в одном массиве никак не затронет другой.
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1                    // cкопировали arr1 в arr2

fmt.Println(arr1, arr2)         // [1 2 3] [1 2 3]
fmt.Println(arr1 == arr2)       // true
fmt.Println(&arr1[0], &arr2[0]) // 0xc0000a4000 0xc0000a4018

arr1[0] = 45
fmt.Println(arr1, arr2)         // [45 2 3] [1 2 3]
```
Так же копирование массива происходит при передачи его в функцию в качестве аргумента. 
```go
package main

import "fmt"

func main() {
    arr := [2]string{"one", "two"}
    change(arr)
    fmt.Println("После функции:", arr)
}

func change(a [2]string) {
    a[0] = "change"
    fmt.Println("В функции:", a)
}
```
Получим вывод, показывающий, что исходный массив никак не изменился(в функции мы работали с копией).
```bash
В функции: [change two]
После функции: [one two]
```
## Сравнение массивов <a name="comparison"></a>
Массивы сравнимы если имеют одинаковую длину и тип элементов, иначе это вызовет ошибку `mismatched types`. 
Массивы равны если их соответствующие элементы равны. Можно использовать операторы сравнения `==` и `!=`, прочие операторы недопустимы.  
```go
arr1 := [2]int{1, 2}
arr2 := [2]int{1, 3}
fmt.Println(arr1 == arr2) // false
fmt.Println(arr1 != arr2) // true
fmt.Println(arr1 > arr2)  // invalid operation: arr1 > arr2 (operator > not defined on array)
```

## Циклы <a name="cycles"></a>

### For <a name="for"></a>
```go
arr := [3]int{1, 2, 3}
for i := 0; i < len(arr); i++ {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
### For range <a name="for-range"></a>
Для изменения текущего массива нужно обращаться через индексы:
```go
arr := [3]int{1, 2, 3}
for i := range arr {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
Без этого текущий массив не будет изменен:
```go 
arr := [3]int{1, 2, 3}
for _, v := range arr {
    v = v * 2
    fmt.Println(v) // на кажом шаге итерации, последовательно -> 2 4 6
}
fmt.Println(arr) // [1 2 3] массив не изменен
```

## Многомерные массивы <a name="multi-arr"></a>
```go
var two [2][3]int
for i := 0; i < 2; i++ {
    for j := 0; j < 3; j++ {
        two[i][j] = i + j
    }
}
fmt.Println(two) // [[0 1 2] [1 2 3]]
```

## Конвертации <a name="сonversions"></a>

### Array -> Slice <a name="arr-slice"></a>
```go
arr :=  [3]int{1, 2, 3}
slice := arr[:] // slice [1 2 3] является ссылкой на arr
```

## Частые операции <a name="often-operations"></a>

### Проверить, существует ли элемент <a name="check-element"></a>
Чтобы определить, существует ли определенный элемент в массиве, нам нужно перебрать каждый элемент массива, используя цикл `for`, и проверить, используя условие `if`. 
