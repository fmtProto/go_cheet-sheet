## `Array(Массив)`
> - [Объявление](#var-declaration)
> - [Обращение](#var-read)
> - [Запись / Перезапись](#var-write)
> - [Удаление](#var-delete)
> - [Длина](#len)
> - [Копирование](#copy)
> - [Добавление](#add)
> - [Циклы](#cycles)
>    - for
>    - for range
> - [Конвертация](#сonversion)
>    - array -> slice

**`Array(Массив)`** - непрерывная последовательность элементов одного типа, обладающая фиксированной, неизменяемой длиной.
- элементы массива хранятся в памяти последовательно и непрерывно
- все элементы массива имеют одинаковый тип данных
- длина  массива неизменяема
- массив по  умолчанию передается по значению, то есть копируется
- длина массива - это часть его типа, поэтому массивы с разной длиной, хоть и с одинаковыми элементами не соответствуют по типу  и  соответсвенно не равны

## Объявление <a name="var-declaration"></a>
```go
var arr [размер]тип_элементов{элемент1, элемент2, элементN}

var arr [3]int               // [0 0 0]
arr1 := [3]int{}             // [0 0 0]
arr2 := [...]int{1, 2, 3}    // [1 2 3] на основании количества элементов вычислить длину
arr3 := [3]int{1: 12, 2: 25} // [0 12 25] присвоить значения по индексу
```

## Обращение <a name="var-read"></a>

Через индексы, имеет  сложность `O(1)`:
```go
arr := [3]int{1, 2, 3}
fmt.Println(arr[1]) // 2
```

## Запись / Перезапись <a name="var-write"></a>

Через индексы, имеет  сложность `O(1)`:
```go
arr := [3]int{1, 2, 3}
arr[1] = 45
fmt.Println(arr[1]) // 45
```

## Удаление <a name="var-delete"></a>
Невозможно! Длина массива неизменяема!  

## Длина <a name="len"></a>
`len()` - вернет количество элементов
```go
arr := [3]int{1, 2, 3}
fmt.Println(len(arr)) // 3
```

## Копирование <a name="copy"></a>
Через присвоение:
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1
// arr1 и arr2 равны друг другу, имеют РАЗНОЕ адрессное пространство и никак не связанны друг с другом
```

## Добавление <a name="add"></a>
Невозможно! Длина массива неизменяема! 

## Циклы <a name="cycles"></a>
### For
```go
arr := [3]int{1, 2, 3}
for i := 0; i < len(arr); i++ {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
### For range
Для изменения текущего массива нужно обращаться через индексы:
```go
arr := [3]int{1, 2, 3}
for i := range arr {
    arr[i] = arr[i] * 2
}
fmt.Println(arr) // [2 4 6]
```
Без этого текущий массив не будет изменен:
```go 
arr := [3]int{1, 2, 3}
for _, v := range arr {
    v = v * 2
    fmt.Println(v) // на кажом шаге итерации, последовательно -> 2 4 6
}
fmt.Println(arr) // [1 2 3] массив не изменен
```

## Конвертация <a name="сonversion"></a>

### Array -> Slice
```go
arr :=  [3]int{1, 2, 3}
slice := arr[:] // slice [1 2 3] является ссылкой на arr
```
