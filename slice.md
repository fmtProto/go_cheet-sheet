## `Slice(Срез)`

> - [Объявление среза](#declaration)
> - [Элементы среза](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина среза](#len)
> - [Копирование среза](#copy)
> - [Сравнение срезов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные срезы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение среза
>   - Содержит ли один срез, значения другого среза

**`Slice(Срез)`** - в отличие от массива, изменяемая по длине последовательность элементов одного типа, является ссылкой на массив.  
В исходниках Go срез представлен как:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
- срез - это ссылка на массив, поэтому при создании среза всегда есть базовый массив
- срез можно создать "с нуля" или нарезать уже существующий массив или срез
- при работе со срезами, стоит не забывать об утечке памяти. Например, если с большого массива взять срез, и работать только со срезом, то массив будет находиться в памяти, несмотря на то, что он нам не нужен
- помимо длины(`len`) срез обладает вместимостью(`cap` или `capacity`)
- cрез может менять свой размер и динамически аллоцировать память, но стоит помнить о том, что при выходе за границы `capacity`, происходит затратное копирование с новым увеличенным `capacity`
- `capacity` увеличивается по определенному алгоритму (___ДОПИСАТЬ___)

## Объявление среза <a name="declaration"></a>
Есть несколько способов создать срез: 
- **с использованием литерала среза**. Такой формат объявления среза отличается от формата объявления массива лишь одним - отсутвием указания длины.
```go
// формат объявления среза через литерал
var slice_name = []dataType{value1, value2, valueN}
slice_name := []dataType{value1, value2, valueN} 

// примеры
var s1 = []int{1, 2, 3}      // [1 2 3]
s2 := []string{"one", "two"} // [one two]
s3 := []int{}                // [] без указания элементов
```

В срезе можно инициализировать элементы по определенным индексам, явно указав их.
```go 
s := []int{1: 12, 5: 6} // [0 12 0 0 0 6] len = 6, cap = 6
```

Срез без указания элементов, всегда является пустым(`len` и `cap` будут 0), но в случае когда нет фигурных скобок `{}` то срез равен `nil`, в этом случае нет базового массива(`len` и `cap` так же будут 0).
```go
var s1 []int           // [] 
fmt.Println(s1 == nil) // true

var s2 = []float32{} // []
s3 := []bool{}       // []
s4 := []string{}     // []
```
- **создать срез из массива**. Имеет формат - `arr[start:end]`, где:
    - `arr` - массив, с которого берем срез
    - `start` - начальный индекс, значение под начальным индексом будет включено в срез
    - `end` - конечный индекс, значение под конечным индексом НЕ будет включено в срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s := arr[1:3] // [14 16]
```
`start` и `end` можно опускать, как по отдельности, так и вместе.
    - отсутвие `start` возмет срез с начала массива, то есть с  индекса `0`
    - отсутвие `end` возмет срез до конца массива, то есть до индекса `len(arr)- 1`
    - отсвутвие обоих из массива возмет все значения, то есть создаст индентичный срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s1 := arr[:3] // [12 14 16]
s2 := arr[1:] // [14 16 18 20]
s3 := arr[:]  // [12 14 16 18 20]
```
- **создать срез из среза**. Имеет формат - `slice[start:end]`, где:
    - `slice` - срез, с которого берем срез
    - `start` - начальный индекс, значение под начальным индексом будет включено в срез
    - `end` - конечный индекс, значение под конечным индексом НЕ будет включено в срез
___ДОПИСАТЬ___

- **используя `make()`**. `make()` - позволяет создавать срез только с нулевыми значениями, с указанием нужного `len` и `cap`. Имеет формат - `make([]type, length, capacity)` (если `cap` не указан, то равен `len`)

`len` - длина среза(количество элементов), `cap` - емкость(вместимость) длина базового массива(считается с первого элемента в срезе).
```go
// если cap не указан, то равен len
s1 := make([]int, 3)              // len = cap = 3
fmt.Println(s1, len(s1), cap(s1)) // [0 0 0] 3 3

s2 := make([]int, 3, 10)          // len = 3, cap = 10
fmt.Println(s2, len(s2), cap(s2)) // [0 0 0] 3 10

s3 := make([]int, 0, 10)          // len = 0, cap = 10
fmt.Println(s3, len(s3), cap(s3)) // [] 0 10
```
К `cap` следут  относиться как к заранне выделенной памяти, потому что если `cap` недостаточно, то придется копировать  существующий базовый массив в новые ячейки с увеличенным количеством памяти, что дорого. 
Есть определенный алгоритм автоматического увелечния `cap` ___ДОПИСАТЬ ___

В примере  ниже, хоть добавился 1 элемент, но `cap` удвоилось.
```go
s := make([]int, 3) // [0 0 0] len = 3, cap = 3
s = append(s, 26)   // [0 0 0 26] len = 4, cap = 6
```
## Обращение к элементам <a id="#var-read"></a>
Получить доступ к определенному элементу среза, можно обратившись к номеру индекса. имеет сложность O(1):

## Изменение элементов <a id="#var-edit"></a>
Изменить значение определенного элемента среза, можно также обратившись к номеру индекса. имеет сложность O(1):

## Удаление
Если `i` - индекс удаляемого элемента
```go
s = append(s[:i], s[i+1:]...)
```
Пример:
```go
s := []int{1, 2, 3}
s = append(s[:1], s[2:]...) // [1 3]
```

## Копирование
`copy()`

## Добавление
`append()`
