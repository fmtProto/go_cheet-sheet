## `Slice(Срез)`

> - [Объявление среза](#declaration)
>   - [Используя литерал среза](#literal)
>   - [Срез из массива](#slice-from-arr)
>   - [Cрез из среза](#slice-from-slice)
>   - [Используя `make()`](#make-declaration)
>   - [Используя `new()`](#new-declaration)
> - [Элементы среза](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина среза](#len)
> - [Копирование среза](#copy)
> - [Сравнение срезов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные срезы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение среза
>   - Содержит ли один срез, значения другого среза

**`Slice(Срез)`** - в отличие от массива, изменяемая по длине последовательность элементов одного типа, является ссылкой на массив.  
В исходниках Go срез представлен как:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
- срез - это ссылка на массив, поэтому срез ничего не хранит, а только ссылается на базовый массив, кроме случая `nil среза`
- срез можно создать "с нуля"(через литерал, `make()`, `new()`) или нарезать уже существующий массив или срез
- при работе со срезами, стоит не забывать об утечке памяти - маленький срез может ссылаться на огромный, тяжелый массив.
- понимание длины(`len`) и вместимости(`cap` или `capacity`) очень важно для грамотной работы со  срезами 
- cрез может менять свой размер и динамически аллоцировать память, но стоит помнить о том, что при выходе за границы `capacity`, происходит затратное копирование с новым увеличенным `capacity`
- `capacity` увеличивается автоматически по определенному алгоритму (___ДОПИСАТЬ поменялось___)

## Объявление среза <a name="declaration"></a>

### Используя литерал среза. <a name="literal"></a>   
При создании среза с помощью литерала, "под капотом" сначала создается массив, а затем возвращается ссылка на него. Формат объявления среза через литерал отличается от формата объявления массива лишь одним - отсутвием указания длины.
```go
// формат объявления массива 
var array_name = [length]dataType{value1, value2, valueN}
array_name := [length]dataType{value1, value2, valueN} 

// формат объявления среза через литерал
var slice_name = []dataType{value1, value2, valueN}
slice_name := []dataType{value1, value2, valueN} 

// примеры
var s1 = []int{1, 2, 3}      // [1 2 3]
s2 := []string{"one", "two"} // [one two]
s3 := []int{}                // [] пустой срез
```

Срез без элементов, всегда является пустым или равным `nil`(если опущены `{}`). В обоих случаях `len` и `cap` среза будут равны 0. Пустой срез и `nil срез` это не одно и тоже, пустой срез имеет базовый массив, а `nil срез` такого массива не имеет(ни на что не  ссылается). Независимо от того, используется пустой или `nil срез`, встроенные функции `append`, `len`, а также `cap` работать будут одинаково. 
```go
var s1 []int           // [] nil срез
fmt.Println(s1 == nil) // true

var s2 = []int{}       // [] пустой срез
fmt.Println(s2 == nil) // false

fmt.Println(s1 == s2) // invalid operation: s1 == s2 (slice can only be compared to nil)
```

В срезе можно инициализировать элементы по определенным индексам, явно указав их.
```go 
s := []int{1: 12, 5: 6} // [0 12 0 0 0 6] len = 6, cap = 6
```

При объявлении среза можно использовать многострочный синтаксис. После последнего элемента обязательно должна присутствовать запятая.
```go
s := []int{
    23,
    678,
    12,
    56,
} // [23 678 12 56]
```

### Срез из массива. <a name="slice-from-arr"></a>  
Если имеется массив,то на основе его можно создать срез(ы) с нужными элементами, нарезав этот массив. Имеет формат - `arr[start:end]`, где: 
- `arr` - массив, с которого берем срез
- `start` - начальный индекс, значение под начальным индексом будет включено в срез
- `end` - конечный индекс, значение под конечным индексом НЕ будет включено в срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s := arr[1:3] // [14 16]
```

`start` и `end` можно опускать, как по отдельности, так и вместе.
- отсутвие `start` возмет срез с начала массива, то есть с `0`
- отсутвие `end` возмет срез до конца массива, то есть до `len(arr)`
- отсвутвие обоих из массива возмет все значения, то есть создаст индентичный срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s1 := arr[:3] // [12 14 16]
s2 := arr[1:] // [14 16 18 20]
s3 := arr[:]  // [12 14 16 18 20]
```

###  Cрез из среза. <a name="slice-from-slice"></a>   
Имеет синтаксис полностью индентичный синтаксису взятию среза из массива(описан выше). В срезе из среза мы можем получить только те значения, которые представленны в срезе-доноре.
```go
arr := [5]int{12, 14, 16, 18, 20}

s1 := arr[1:4] // [14 16 18]
s2 := s1[:2]   // [14 16]
s3 := s1[:]    // [14 16 18]
```

### Используя `make()`. <a name="make-declaration"></a>
`make()` - позволяет создавать срез с нулевыми значениями типа, с указанием нужного `len` и `cap`.  
Имеет формат - `make([]type, len, cap)` (если `cap` не указан, то равен `len`)

`len` - длина, количество элементов в срезе, `cap` - емкость(вместимость), длина базового массива, считая с первого элемента в срезе.
```go
// если cap не указан, то равен len
s1 := make([]int, 3)              // len = cap = 3
fmt.Println(s1, len(s1), cap(s1)) // [0 0 0] 3 3

s2 := make([]int, 3, 10)          // len = 3, cap = 10
fmt.Println(s2, len(s2), cap(s2)) // [0 0 0] 3 10

s3 := make([]int, 0, 10)          // len = 0, cap = 10
fmt.Println(s3, len(s3), cap(s3)) // [] 0 10
```
К `cap` следут  относиться как к заранне выделенной памяти, потому что если `cap` недостаточно, то придется копировать  существующий базовый массив в новые ячейки с увеличением количества памяти, что дорого. 
Есть определенный алгоритм автоматического увелечния `cap` ___ДОПИСаТЬ ___

В примере  ниже, хоть добавился 1 элемент, но `cap` удвоилось.
```go
s := make([]int, 3) // [0 0 0] len = 3, cap = 3
s = append(s, 26)   // [0 0 0 26] len = 4, cap = 6
```

### Используя `new()`. <a name="new-declaration"></a>
Используется редко. В отличие от `make()` возвращает указатель.
```go
s := new([50]int)[0:10]
fmt.Println(s, len(s), cap(s)) // [0 0 0 0 0 0 0 0 0 0] 10 50

s1 := new([]int)
fmt.Println(s1) // &[]
```

## Элементы срезa <a name="elements"></a>  

### Обращение к элементам <a name="read"></a>
Получить доступ к определенному элементу среза, можно обратившись к нему по номеру индекса.  
Имеет сложность `O(1)`.
```go
s := []string{"one", "two", "three"}
fmt.Println(s[1]) // two
```

При попытке получить доступ к элементу за пределами диапазона среза, случится `panic`.
```go 
s := []string{"one", "two", "three"}
fmt.Println(s[3]) // panic: runtime error: index out of range [3] with length 3
```

Go не поддерживает обратную индексацию с использованием отрицательных чисел, будет выведена ошибка.
```go
s := []string{"one", "two", "three"}
fmt.Println(s[-1]) // invalid argument: index -1 (constant of type int) must not be negative
```

### Изменение элементов <a name="edit"></a>
Изменить значение определенного элемента среза, можно также обратившись к номеру индекса.  
Имеет сложность `O(1)`.
```go
s := []string{"one", "two", "three"}
s[1] = "five"
fmt.Println(s) // [one five three]
```

При попытке получить доступ к элементу за пределами диапазона среза, случится `panic`.
```go
s := []string{"one", "two", "three"}
s[5] = "five" // panic: runtime error: index out of range [5] with length 3
```

При попытке изменить элемент на значение другого типа, вызовет ошибку.
```go
s := []string{"one", "two", "three"}
s[5] = 5 // cannot use 5 (untyped int constant) as string value in assignment
```

### Добавление элементов <a name="add"></a>
Встроенная функция `append()` добавляет элементы в конец среза. Если базовый массив имеет достаточную емкость, то значения просто добавляются, если это не так, будет выделен новый базовый массив с увеличенной емкостью. `append()` возвращает обновленный срез, поэтому необходимо сохранить результат добавления, часто в переменной, содержащей сам срез.
```go 
s := []string{"one", "two", "three"}
fmt.Println(s, len(s), cap(s)) // [one two three] 3 3
fmt.Printf("%p", s) // 0xc000070150

s = append(s, "four")

fmt.Println(s, len(s), cap(s)) // [one two three four] 4 6
fmt.Printf("%p", s) // 0xc00005c180
// выделен новый массив, все данные скопировались в него с добавлением нового значения
```
Пример выше простой, и копирование массива незатратное, а что будет если это будет тяжелый массив с большим количеством занимаемой памяти, поэтому аллокаций надо стараться избегать, ведь в копировании тяжелого массива из за добавления в срез одного значения, нет ни грамма разумности.


## Удаление
Если `i` - индекс удаляемого элемента
```go
s = append(s[:i], s[i+1:]...)
```
Пример:
```go
s := []int{1, 2, 3}
s = append(s[:1], s[2:]...) // [1 3]
```

## Копирование
`copy()`

## Добавление
`append()`
