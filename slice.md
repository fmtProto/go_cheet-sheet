## `Slice(Срез)`

> - [Объявление среза](#declaration)
>   - [Использование литерала среза](#literal)
>   - [Срез из массива](#slice-from-arr)
> - [Элементы среза](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина среза](#len)
> - [Копирование среза](#copy)
> - [Сравнение срезов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные срезы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение среза
>   - Содержит ли один срез, значения другого среза

**`Slice(Срез)`** - в отличие от массива, изменяемая по длине последовательность элементов одного типа, является ссылкой на массив.  
В исходниках Go срез представлен как:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
- срез - это ссылка на массив, поэтому срез ничего не хранит, а только ссылается на базовый массив, кроме случая `nil среза`
- срез можно создать "с нуля"(через литерал, `make()`, `new()`) или нарезать уже существующий массив или срез
- при работе со срезами, стоит не забывать об утечке памяти - маленький срез может ссылаться на огромный, тяжелый массив.
- понимание длины(`len`) и вместимости(`cap` или `capacity`) очень важно для грамотной работы со  срезами 
- cрез может менять свой размер и динамически аллоцировать память, но стоит помнить о том, что при выходе за границы `capacity`, происходит затратное копирование с новым увеличенным `capacity`
- `capacity` увеличивается автоматически по определенному алгоритму (___ДОПИСАТЬ поменялось___)

## Объявление среза <a name="declaration"></a>

### **Использование литерала среза**. <a name="literal"></a>   
Формат объявления среза через литерал отличается от формата объявления массива лишь одним - отсутвием указания длины.
```go
// формат объявления массива 
var array_name = [length]dataType{value1, value2, valueN}
array_name := [length]dataType{value1, value2, valueN} 

// формат объявления среза через литерал
var slice_name = []dataType{value1, value2, valueN}
slice_name := []dataType{value1, value2, valueN} 

// примеры
var s1 = []int{1, 2, 3}      // [1 2 3]
s2 := []string{"one", "two"} // [one two]
s3 := []int{}                // [] пустой срез
```

Срез без элементов, всегда является пустым или равным `nil`(если опущены `{}`). В обоих случаях `len` и `cap` среза будут равны 0. Пустой срез и `nil срез` это не одно и тоже, пустой срез имеет базовый массив, а `nil срез` такого массива не имеет(ни на что не  ссылается). Независимо от того, используется пустой или `nil срез`, встроенные функции `append`, `len`, а также `cap` работать будут одинаково. 
```go
var s1 []int           // [] nil срез
fmt.Println(s1 == nil) // true

var s2 = []int{}       // [] пустой срез
fmt.Println(s2 == nil) // false

fmt.Println(s1 == s2) // invalid operation: s1 == s2 (slice can only be compared to nil)
```

В срезе можно инициализировать элементы по определенным индексам, явно указав их.
```go 
s := []int{1: 12, 5: 6} // [0 12 0 0 0 6] len = 6, cap = 6
```

При объявлении среза() можно использовать многострочный синтаксис. После последнего элемента обязательно должна присутствовать запятая.
```go
s := []int{
    23,
    678,
    12,
    56,
} // [23 678 12 56]
```

### **Срез из массива**. <a name="slice-from-arr"></a>  
Имеет формат - `arr[start:end]`, где: 
- `arr` - массив, с которого берем срез
- `start` - начальный индекс, значение под начальным индексом будет включено в срез
- `end` - конечный индекс, значение под конечным индексом НЕ будет включено в срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s := arr[1:3] // [14 16]
```

`start` и `end` можно опускать, как по отдельности, так и вместе.
    - отсутвие `start` возмет срез с начала массива, то есть с  индекса `0`
    - отсутвие `end` возмет срез до конца массива, то есть до индекса `len(arr)`
    - отсвутвие обоих из массива возмет все значения, то есть создаст индентичный срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s1 := arr[:3] // [12 14 16]
s2 := arr[1:] // [14 16 18 20]
s3 := arr[:]  // [12 14 16 18 20]
```
- **создать срез из среза**. Имеет формат - `slice[start:end]`, где:
    - `slice` - срез, с которого берем срез
    - `start` - начальный индекс, значение под начальным индексом будет включено в срез
    - `end` - конечный индекс, значение под конечным индексом НЕ будет включено в срез
___ДОПИСАТЬ___

- **используя `make()`**. `make()` - позволяет создавать срез только с нулевыми значениями, с указанием нужного `len` и `cap`. Имеет формат - `make([]type, len, cap)` (если `cap` не указан, то равен `len`)

`len` - длина, количество элементов в срезе, `cap` - емкость(вместимость), длина базового массива, считая с первого элемента в срезе.
```go
// если cap не указан, то равен len
s1 := make([]int, 3)              // len = cap = 3
fmt.Println(s1, len(s1), cap(s1)) // [0 0 0] 3 3

s2 := make([]int, 3, 10)          // len = 3, cap = 10
fmt.Println(s2, len(s2), cap(s2)) // [0 0 0] 3 10

s3 := make([]int, 0, 10)          // len = 0, cap = 10
fmt.Println(s3, len(s3), cap(s3)) // [] 0 10
```
К `cap` следут  относиться как к заранне выделенной памяти, потому что если `cap` недостаточно, то придется копировать  существующий базовый массив в новые ячейки с увеличенным количеством памяти, что дорого. 
Есть определенный алгоритм автоматического увелечния `cap` ___ДОПИСАТЬ ___

В примере  ниже, хоть добавился 1 элемент, но `cap` удвоилось.
```go
s := make([]int, 3) // [0 0 0] len = 3, cap = 3
s = append(s, 26)   // [0 0 0 26] len = 4, cap = 6
```
## Обращение к элементам <a id="#var-read"></a>
Получить доступ к определенному элементу среза, можно обратившись к номеру индекса. имеет сложность O(1):

## Изменение элементов <a id="#var-edit"></a>
Изменить значение определенного элемента среза, можно также обратившись к номеру индекса. имеет сложность O(1):

## Удаление
Если `i` - индекс удаляемого элемента
```go
s = append(s[:i], s[i+1:]...)
```
Пример:
```go
s := []int{1, 2, 3}
s = append(s[:1], s[2:]...) // [1 3]
```

## Копирование
`copy()`

## Добавление
`append()`
