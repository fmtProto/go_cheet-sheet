## `Slice(Срез)`

> - [Объявление среза](#declaration)
> - [Элементы среза](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина среза](#len)
> - [Копирование среза](#copy)
> - [Сравнение срезов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные срезы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение среза
>   - Содержит ли один срез, значения другого среза

**`Slice(Срез)`** - в отличие от массива, изменяемая по длине последовательность элементов одного типа, является ссылкой на массив.  
В исходниках Go срез представлен как:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
- срез - это ссылка на массив, поэтому при создании среза всегда есть основополагающий массив
- срез можно создать "с нуля" или нарезать уже существующий массив или срез
- при работе со срезами, стоит не забывать об утечке памяти. Например, если с большого массива взять срез, и работать только со срезом, то массив будет находиться в памяти, несмотря на то, что он нам не нужен
- помимо длины(`len`) срез обладает вместимостью(`cap` или `capacity`)
- срез можно увеличивать по длине(в отличие от массива), но стоит помнить о том, что при выходе за границы `capacity`, происходит затратное копирование с новым увеличенным `capacity`
- `capacity` увеличивается по определенному алгоритму (___ДОПИСАТЬ___)

## Объявление среза <a name="declaration"></a>
Формат объявления cреза отличается от формата объявления массива лишь одним - отсутвием указания длины.
```go
// формат объявления среза 
var slice_name = []dataType{value1, value2, valueN}
slice_name := []dataType{value1, value2, valueN} 

// примеры
var s1 = []int{1, 2, 3}      // [1 2 3]
s2 := []string{"one", "two"} // [one two]
s3 := []int{}                // [] без указания элементов
```
Срез объявленный без композитного литерала не имеет базового массива(ни на что не указывает), поэтому его значение - `nil`. Пустой срез и срез nil не эквивалентны
```go
var s1 []int           // []    len = 0, cap = 0  без композитного литерала
fmt.Println(s1 == nil) // true

s2 := []int{}          // []    len = 0, cap = 0
fmt.Println(s2 == nil) // false
```


```go 
s1 := []int{1, 2, 3}     // [1 2 3]        len = 3, cap = 3
s2 := []int{1: 12, 5: 6} // [0 12 0 0 0 6] len = 6, cap = 6
```
### Используя `make()`

`make()` - позволяет явно указать `len` и `cap`, создает срез только с нулевыми значениями
`len` - длина, `cap` - емкость(вместимость).
`len` - сколько элементов в срезе, `cap` - сколько элементов может  содержать срез(до перерасчета `cap`).
`cap` - количество элементов в базовом массиве,считая от первого элемента в срезе.
Cap — ключевой параметр для аллокации памяти, влияет на производительность вставки в срез.
len (length, длина) — текущая длина среза, cap (capacity, вместимость) — длина внутреннего массива.

```go
s1 := make([]int, 3) // если cap не указан, то равен len
fmt.Println(s1, len(s1), cap(s1)) // [0 0 0] 3 3

s2 := make([]int, 3, 10) // cap = 10
fmt.Println(s2, len(s2), cap(s2)) // [0 0 0] 3 10

s3 := make([]int, 0, 10) // len = 10 , cap = 10
fmt.Println(s3, len(s3), cap(s3)) // [] 0 10
```
К `cap` следут  относиться как к заранне выделенной памяти, потому что если `cap` недостаточно, то придется копировать  существующий массив(срез) в новые ячейки с увеличенным количеством памяти, что дорого. 
Есть определенный алгоритм автоматического увелечния `cap` ___ДОПИСАТЬ ___

В примере  ниже, хоть добавился 1 элемент, но `cap` удвоилось.
```go
s := make([]int, 3) // [0 0 0] len = 3, cap = 3
s = append(s, 26)   // [0 0 0 26] len = 4, cap = 6
```
## Обращение к элементам <a id="#var-read"></a>
Получить доступ к определенному элементу среза, можно обратившись к номеру индекса. имеет сложность O(1):

## Изменение элементов <a id="#var-edit"></a>
Изменить значение определенного элемента среза, можно также обратившись к номеру индекса. имеет сложность O(1):

## Удаление
Если `i` - индекс удаляемого элемента
```go
s = append(s[:i], s[i+1:]...)
```
Пример:
```go
s := []int{1, 2, 3}
s = append(s[:1], s[2:]...) // [1 3]
```

## Копирование
`copy()`

## Добавление
`append()`
