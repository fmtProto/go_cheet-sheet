## `Slice(Срез)`

> - [Объявление среза](#declaration)
>   - [Используя литерал среза](#literal)
>   - [Срез из массива](#slice-from-arr)
>   - [Cрез из среза](#slice-from-slice)
>   - [Используя `make()`](#make-declaration)
>   - [Используя `new()`](#new-declaration)
> - [Элементы среза](#elements)
>   - [Обращение к элементам](#read)
>   - [Изменение элементов](#edit)
>   - [Добавление элементов](#add)
>   - [Удаление элементов](#delete)
> - [Длина среза](#len)
> - [Копирование среза](#copy)
> - [Сравнение срезов](#comparison)
> - [Циклы](#cycles)
>   - [for](#for)
>   - [for range](#for-range)
> - [Многомерные срезы](#multi-arr)
> - [Конвертации](#сonversions)
>    - [array -> slice](#arr-slice)
> - [Частые операции](#often-operations)
>   - [Проверить, существует ли элемент](#check-element)
>   - Найти наименьшее или наибольшее значение среза
>   - Содержит ли один срез, значения другого среза

**`Slice(Срез)`** - в отличие от массива, изменяемая по длине последовательность элементов одного типа, является ссылкой на массив.  
В исходниках Go срез представлен как:
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
- срез - это ссылка на массив, поэтому срез ничего не хранит, а только ссылается на часть базового массива, кроме случая `nil среза`
- при изменении элемента среза, изменяется соответствующий элемент его базового массива, поэтому другие слайсы, которые используют один и тот же базовый массив, увидят изменения. 
- срез можно создать "с нуля"(через литерал, `make()`, `new()`) или нарезать уже существующий массив или срез
- при работе со срезами, стоит не забывать об утечке памяти - маленький срез может ссылаться на огромный, тяжелый массив.
- понимание длины(`len`) и вместимости(`cap` или `capacity`) очень важно для грамотной работы со  срезами 
- cрез может менять свой размер и динамически аллоцировать память, но стоит помнить о том, что при выходе за границы `capacity`, происходит затратное копирование с новым увеличенным `capacity`
- `capacity` увеличивается автоматически по определенному алгоритму (___ДОПИСАТЬ поменялось___)

## Объявление среза <a name="declaration"></a>

### Используя литерал среза. <a name="literal"></a>   
При создании среза с помощью литерала, "под капотом" сначала создается массив, а затем возвращается ссылка на него. Формат объявления среза через литерал отличается от формата объявления массива лишь одним - отсутвием указания длины.
```go
// формат объявления массива 
var array_name = [length]dataType{value1, value2, valueN}
array_name := [length]dataType{value1, value2, valueN} 

// формат объявления среза через литерал
var slice_name = []dataType{value1, value2, valueN}
slice_name := []dataType{value1, value2, valueN} 

// примеры
var s1 = []int{1, 2, 3}      // [1 2 3]
s2 := []string{"one", "two"} // [one two]
s3 := []int{}                // [] пустой срез
```

Срез без элементов, всегда является пустым или равным `nil`(если опущены `{}`). В обоих случаях `len` и `cap` среза будут равны 0. Пустой срез и `nil срез` это не одно и тоже, пустой срез имеет базовый массив, а `nil срез` такого массива не имеет(ни на что не  ссылается). Независимо от того, используется пустой или `nil срез`, встроенные функции `append`, `len`, а также `cap` работать будут одинаково. 
```go
var s1 []int           // [] nil срез s1:=[]int(nil)
fmt.Println(s1 == nil) // true

var s2 = []int{}       // [] пустой срез
fmt.Println(s2 == nil) // false

fmt.Println(s1 == s2) // invalid operation: s1 == s2 (slice can only be compared to nil)
```

В срезе можно инициализировать элементы по определенным индексам, явно указав их.
```go 
s := []int{1: 12, 5: 6} // [0 12 0 0 0 6] len = 6, cap = 6
```

При объявлении среза можно использовать многострочный синтаксис. После последнего элемента обязательно должна присутствовать запятая.
```go
s := []int{
    23,
    678,
    12,
    56,
} // [23 678 12 56]
```

### Срез из массива. <a name="slice-from-arr"></a>  
Если имеется массив,то на основе его можно создать срез(ы) с нужными элементами, нарезав этот массив. Имеет формат - `arr[start:end]`, где: 
- `arr` - массив, с которого берем срез
- `start` - нижняя граница(индекс элемента), значение будет включено в срез
- `end` - верхняя граница(индекс элемента), значение НЕ будет включено в срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s := arr[1:3] // [14 16]
```

`start` и `end` можно опускать, как по отдельности, так и вместе:
- отсутвие `start` возмет срез с начала массива, то есть с `0`
- отсутвие `end` возмет срез до конца массива, то есть до `len(arr)`
- отсвутвие обоих возмет из массива все значения, то есть создаст индентичный срез
```go
arr := [5]int{12, 14, 16, 18, 20}
s1 := arr[:3] // [12 14 16]
s2 := arr[1:] // [14 16 18 20]
s3 := arr[:]  // [12 14 16 18 20]
```

###  Cрез из среза. <a name="slice-from-slice"></a>   
Имеет синтаксис полностью индентичный синтаксису взятию среза из массива(описан выше). 
Однако:
- при нарезке среза, индексы относятся к самому срезу, а не к базовому массиву.
- верхняя граница связана не с длиной среза, а с его емкостью, что означает, что длину среза можно увеличить(в примере ниже `s4`). 
```go
arr := [5]int{12, 14, 16, 18, 20}

s1 := arr[1:4] // [14 16 18]
s2 := s1[:2]   // [14 16]
s3 := s1[:]    // [14 16 18]
s4 := s1[:4]   // [14 16 18 20] 
```

### Используя `make()`. <a name="make-declaration"></a>
`make()` - позволяет создавать срез с нулевыми значениями типа, с указанием нужного `len` и `cap`.  
Имеет формат - `make([]type, len, cap)` (если `cap` не указан, то равен `len`)

`len` - длина, количество элементов в срезе, `cap` - емкость(вместимость), длина базового массива, считая с первого элемента в срезе.
```go
// если cap не указан, то равен len
s1 := make([]int, 3)              // len = cap = 3
fmt.Println(s1, len(s1), cap(s1)) // [0 0 0] 3 3

s2 := make([]int, 3, 10)          // len = 3, cap = 10
fmt.Println(s2, len(s2), cap(s2)) // [0 0 0] 3 10

s3 := make([]int, 0, 10)          // len = 0, cap = 10
fmt.Println(s3, len(s3), cap(s3)) // [] 0 10
```
К `cap` следут  относиться как к заранне выделенной памяти, потому что если `cap` недостаточно, то придется копировать существующий базовый массив в новые ячейки с увеличением количества памяти, что дорого. 
Есть определенный алгоритм автоматического увелечния `cap` ___ДОПИСаТЬ ___

В примере  ниже, добавился 1 элемент, но `cap` удвоилось.
```go
s := make([]int, 3) // [0 0 0] len = 3, cap = 3
s = append(s, 26)   // [0 0 0 26] len = 4, cap = 6
```

### Используя `new()`. <a name="new-declaration"></a>
Используется редко. В отличие от `make()` возвращает указатель.
```go
s := new([50]int)[0:10]
fmt.Println(s, len(s), cap(s)) // [0 0 0 0 0 0 0 0 0 0] 10 50

s1 := new([]int)
fmt.Println(s1) // &[]
```

## Элементы срезa <a name="elements"></a>  

### Обращение к элементам <a name="read"></a>
Получить доступ к определенному элементу среза, можно обратившись к нему по номеру индекса.  
Имеет сложность `O(1)`.
```go
s := []string{"one", "two", "three"}
fmt.Println(s[1]) // two
```

При попытке получить доступ к элементу за пределами диапазона среза, случится `panic`.
```go 
s := []string{"one", "two", "three"}
fmt.Println(s[3]) // panic: runtime error: index out of range [3] with length 3
```

Go не поддерживает обратную индексацию с использованием отрицательных чисел, будет выведена ошибка.
```go
s := []string{"one", "two", "three"}
fmt.Println(s[-1]) // invalid argument: index -1 (constant of type int) must not be negative
```

### Изменение элементов <a name="edit"></a>
Изменить значение определенного элемента среза, можно также обратившись к номеру индекса.  
Имеет сложность `O(1)`.
```go
s := []string{"one", "two", "three"}
s[1] = "five"
fmt.Println(s) // [one five three]
```
Любое изменение элементов в срезе(-ах), влияет на базовый массив, и наоборот.
```go
arr := [5]int{1, 2, 3, 4, 5} // [1 2 3 4 5]
s := arr[:]                  // [1 2 3 4 5] срез
ss := s[1:3]                 // [2 3] срез со среза

// меняем в срезе
s[0] = 7
fmt.Println(arr) // [7 2 3 4 5]
fmt.Println(s)   // [7 2 3 4 5]
fmt.Println(ss)  // [2 3]

// меняем в массиве
arr[2] = 11
fmt.Println(arr) // [7 2 11 4 5]
fmt.Println(s)   // [7 2 11 4 5]
fmt.Println(ss)  // [2 11]

// меняем в срезе со среза
ss[0] = 666
fmt.Println(arr) // [7 666 11 4 5]
fmt.Println(s)   // [7 666 11 4 5]
fmt.Println(ss)  // [666 11]
```

При попытке получить доступ к элементу за пределами диапазона среза, случится `panic`.
```go
s := []string{"one", "two", "three"}
s[5] = "five" // panic: runtime error: index out of range [5] with length 3
```

При попытке изменить элемент на значение другого типа, вызовет ошибку.
```go
s := []string{"one", "two", "three"}
s[5] = 5 // cannot use 5 (untyped int constant) as string value in assignment
```

### Добавление элементов <a name="add"></a>
Встроенная функция `append()` добавляет  любое количество элементов в конец среза. Если базовый массив имеет достаточную емкость, то значения просто добавляются, если нет, то будет выделен новый базовый массив с увеличенной емкостью. `append()` возвращает обновленный срез, поэтому необходимо сохранить результат добавления, часто в переменной, содержащей сам срез.   
`append()` имеет синтаксис:
```go
// в исходниках Go
func append(slice []Type, elems ...Type) []Type

// упрощенно
slice = append(slice, elem1, elem2, ...)
```

Пример ниже простой, и копирование массива незатратное, а что будет если это будет тяжелый массив с большим количеством занимаемой памяти, поэтому аллокаций надо стараться избегать.
```go 
s := []string{"one", "two", "three"}
fmt.Println(s, len(s), cap(s)) // [one two three] 3 3
fmt.Printf("%p", s) // 0xc000070150

s = append(s, "four")

fmt.Println(s, len(s), cap(s)) // [one two three four] 4 6
fmt.Printf("%p", s) // 0xc00005c180
// выделен новый массив, все данные скопировались в него с добавлением нового значения
```

Возможно добавлять новые элементы к пустому срезу или `nil срезу`.
```go
s := []int{}   // пустой срез, но вместо него может быть и nil срез(var s []int)
fmt.Println(s) // []

s = append(s, 3, 4)

fmt.Println(s) // [3 4]
```

При помощи `append()` так же можно добавлять элементы одного среза в другой, используя нотацию - `...`. Тип данных элементов обоих срезов естественно должен быть одинаковым. `...` как бы распаковывает `s2`. Без точек код попытается добавить срез целиком, что недопустимо. 
```go
s1 := []string{"one", "two", "three"}
s2 := []string{"four", "five"}
s1 = append(s1, s2...) // [one two three four five]
```

В качестве особого случая допустимо добавлять строку к срезу байтов. Это является исключением!
```go
slice := append([]byte("Hello "), "world!"...) // [72 101 108 108 111 32 119 111 114 108 100 33]
```

## Удаление <a name="delete"></a>
- медленный вариант, сохраняет порядок
```go
i := 1 // индекс удаляемого элемента
s := []int{1, 2, 3, 4, 5}

s = append(s[:i], s[i+1:]...)

fmt.Println(s) // [1 3 4 5]
```
- быстрый вариант, НЕ сохраняет порядок
```go
i := 1 // индекс удаляемого элемента
s := []int{1, 2, 3, 4, 5}

s[i] = s[len(s)-1]
s = s[:len(s)-1]

fmt.Println(s) // [1 5 3 4]
```

## Копирование срезов  <a name="copy"></a>

`copy()`

